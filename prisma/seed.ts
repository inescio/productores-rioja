import { PrismaClient, Role } from '@prisma/client';
import { productoresData as mockProductoresData, categorias as mockCategorias } from '../src/data/productores'; // Ajusta la ruta si es necesario
import { hashSync } from 'bcryptjs';

const prisma = new PrismaClient();

// Define una contrase√±a temporal para todos los productores
const TEMPORARY_PASSWORD = "password123"; // ¬°Aseg√∫rate de que los productores la cambien!
const HASHED_PASSWORD = hashSync(TEMPORARY_PASSWORD, 10);

async function main() {
  console.log(`Start seeding ...`);

  // 1. Seed Categorias
  // Usaremos un Map para acceder f√°cilmente a las categor√≠as creadas por su nombre original
  const categoriasMap = new Map<string, { id: string; nombre: string }>();
  for (const mockCategoria of mockCategorias) {
    // Asumimos que el nombre de la categor√≠a en mockCategorias es √∫nico.
    // Si no, necesitar√≠amos una clave m√°s robusta o ajustar la l√≥gica.
    // Aqu√≠ estamos usando el 'id' de mockCategorias como el nombre √∫nico para la BD.
    // Esto podr√≠a necesitar ajuste si los 'id' de mockCategorias no son los nombres deseados.
    // Para este ejemplo, asumir√© que el `id` del mock es el `nombre` que queremos en la BD.
    // Ej: mockCategoria = { id: 'vinos', nombre: 'Vinos', icon: 'üç∑', color: 'bg-red-100' }
    // En la BD Categoria.nombre = 'vinos'

    const categoriaNombre = mockCategoria.id; // Usando el 'id' del mock como nombre √∫nico

    const categoria = await prisma.categoria.upsert({
      where: { nombre: categoriaNombre },
      update: {},
      create: {
        nombre: categoriaNombre,
      },
    });
    categoriasMap.set(categoriaNombre, categoria);
    console.log(`Created/found categoria: ${categoria.nombre} with id ${categoria.id}`);
  }

  // 2. Seed Productores y sus Productos
  for (let i = 0; i < mockProductoresData.length; i++) {
    const productorData = mockProductoresData[i];
    const userEmail = `productor${i + 1}@example.com`; // Email ficticio

    // Intentar encontrar o crear el usuario
    let user = await prisma.user.findUnique({
      where: { email: userEmail },
    });

    if (!user) {
      user = await prisma.user.create({
        data: {
          email: userEmail,
          name: productorData.nombre, // Usar el nombre del productor como nombre de usuario inicial
          // image: productorData.imagen, // Podr√≠amos usar la imagen del productor como imagen de usuario tambi√©n
          role: Role.PRODUCTOR,
          // Para NextAuth con Credentials, la contrase√±a se verifica en el backend,
          // pero no se almacena directamente en el modelo User si se usa el adaptador est√°ndar sin modificaciones.
          // Para un sistema de login propio o si quisi√©ramos a√±adir un campo password al User:
          // password: HASHED_PASSWORD, // ¬°Aseg√∫rate de que el modelo User tenga un campo password!
          // Por ahora, NextAuth se encargar√° de las credenciales. El HASHED_PASSWORD es conceptual aqu√≠.
        },
      });
      console.log(`Created user: ${user.email}`);
    } else {
      console.log(`Found user: ${user.email}`);
    }

    // Encontrar la categor√≠a correspondiente
    // productorData.categoria es el 'id' del mock (ej: 'vinos')
    const categoriaDB = categoriasMap.get(productorData.categoria);
    if (!categoriaDB) {
      console.warn(`Categor√≠a ${productorData.categoria} no encontrada en categoriasMap. Saltando productor ${productorData.nombre}`);
      continue;
    }

    // Crear o actualizar el Productor
    // Usaremos el nombre del productor como un identificador √∫nico para la carga inicial,
    // asumiendo que no hay dos productores con el mismo nombre en los datos mock.
    // Idealmente, tendr√≠amos un ID √∫nico en los datos mock si no fuera el nombre.
    const productor = await prisma.productor.upsert({
      where: { userId: user.id }, // Un productor por usuario
      update: { // Qu√© actualizar si ya existe (podr√≠amos no querer actualizar nada o solo ciertos campos)
        nombre: productorData.nombre,
        ubicacion: productorData.ubicacion,
        telefono: productorData.telefono,
        whatsapp: productorData.whatsapp,
        instagram: productorData.instagram,
        descripcion: productorData.descripcion,
        imagen: productorData.imagen,
        rating: productorData.rating,
        categoriaId: categoriaDB.id,
        aprobado: true, // Asumimos que los productores del seed est√°n aprobados
        fechaAprobacion: new Date(),
      },
      create: {
        user: {
          connect: { id: user.id },
        },
        nombre: productorData.nombre,
        ubicacion: productorData.ubicacion,
        telefono: productorData.telefono,
        whatsapp: productorData.whatsapp,
        instagram: productorData.instagram,
        descripcion: productorData.descripcion,
        imagen: productorData.imagen,
        rating: productorData.rating,
        categoria: {
          connect: { id: categoriaDB.id },
        },
        aprobado: true,
        fechaSolicitud: new Date(),
        fechaAprobacion: new Date(),
        // Productos se crean despu√©s
      },
    });
    console.log(`Created/updated productor: ${productor.nombre}`);

    // 3. Seed Productos para este Productor
    for (const productoData of productorData.productos) {
      // Asumimos que el nombre del producto es √∫nico POR PRODUCTOR para la carga inicial.
      // Si no, necesitar√≠amos un ID √∫nico en los datos mock del producto.
      await prisma.producto.upsert({
        where: {
          // Necesitamos un identificador √∫nico para el producto si queremos hacer upsert.
          // Si no tenemos uno, podr√≠amos borrar y recrear, o solo crear.
          // Por simplicidad, si el nombre no es √∫nico, esto podr√≠a dar error o actualizar el incorrecto.
          // Vamos a asumir que para el seed, podemos identificarlo por nombre Y productorId.
          // Prisma no soporta unique compuesto en `upsert` directamente en `where` de esta forma simple.
          // Una mejor aproximaci√≥n ser√≠a buscarlo primero.
          // Para este seed, vamos a intentar crear y si falla por constraint √∫nico (si lo tuvi√©ramos), lo saltamos.
          // O, m√°s simple para el seed: borrar los productos existentes de este productor y recrearlos.
          // Aqu√≠, simplemente crearemos, asumiendo que es la primera vez o que no hay conflictos.
          // Para hacerlo idempotente, podr√≠amos hacer:
          // const existingProducto = await prisma.producto.findFirst({ where: { nombre: productoData.nombre, productorId: productor.id }});
          // if (!existingProducto) { ... crear ... }
          // O usar un ID compuesto si el esquema lo permite.
          // Por ahora, solo crearemos, asumiendo que el productor no tiene productos a√∫n o que los nombres son √∫nicos.
          // Si el nombre y productorId fueran un unique compuesto @@unique([nombre, productorId]) en el schema:
          // where: { nombre_productorId: { nombre: productoData.nombre, productorId: productor.id } },
          // update: { ... }, create: { ... }
          // Como no lo tenemos, vamos a crear directamente y si hay error de constraint, lo ignoramos para el seed.
          // Esto es riesgoso. Una mejor forma es limpiar productos del productor antes.
          // Por ahora, por simplicidad en la creaci√≥n:

          // IMPORTANTE: Para que upsert funcione bien, necesitar√≠amos un campo verdaderamente √∫nico
          // o una combinaci√≥n √∫nica en el modelo Producto. Como no lo tenemos expl√≠citamente m√°s all√° del ID,
          // y no queremos depender del ID autogenerado para el matching,
          // vamos a hacer un create. Si el script se corre de nuevo, duplicar√° productos.
          // Para un seed real, se deber√≠a hacer m√°s robusto (ej. borrar productos del productor antes de re-seed).
          // O buscar por nombre y productorId y actualizar si existe.
          id: `${productor.id}-${productoData.id}` // Crear un ID determinista para el seed si es posible
        },
        update: {
            nombre: productoData.nombre,
            descripcion: productoData.descripcion || null, // Asegurar que undefined sea null
            imagen: productoData.imagen,
            precio: productoData.precio,
            disponible: productoData.disponible,
        },
        create: {
          id: `${productor.id}-${productoData.id}`, // Crear un ID determinista para el seed
          nombre: productoData.nombre,
          descripcion: productoData.descripcion || null,
          imagen: productoData.imagen,
          precio: productoData.precio,
          disponible: productoData.disponible,
          productor: {
            connect: { id: productor.id },
          },
        }
      });
      console.log(`  Created/updated producto: ${productoData.nombre} for ${productor.nombre}`);
    }
  }

  console.log(`Seeding finished.`);
}

main()
  .catch(async (e) => {
    console.error(e);
    await prisma.$disconnect();
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

// Nota sobre HASHED_PASSWORD y User:
// Si tu modelo User en schema.prisma NO tiene un campo 'password',
// entonces no puedes asignar HASHED_PASSWORD al crearlo.
// NextAuth con el provider 'Credentials' maneja la verificaci√≥n de la contrase√±a
// en su propia l√≥gica, usualmente comparando el input con un hash que S√ç guardar√≠as
// si el modelo User tuviera el campo password.
// Para el adaptador de Prisma, User.email es la clave.
// Si vas a implementar tu propio almacenamiento de hash de contrase√±a en el modelo User,
// aseg√∫rate de a√±adir `password String?` (o similar) a tu `schema.prisma` y re-migrar.
// Para este seed, asumimos que el setup de NextAuth se har√° luego y que el User creado aqu√≠
// ser√° usado por NextAuth. La contrase√±a temporal es para que sepas qu√© usar al probar el login.
// La gesti√≥n real del hash y la comparaci√≥n la har√° NextAuth o tu l√≥gica de /api/auth.
```

**Explicaci√≥n y Puntos Clave del Script:**

1.  **Importaciones:** Se importa `PrismaClient`, los datos mock, y `hashSync` de `bcryptjs`.
2.  **Contrase√±a Temporal:** Se define `TEMPORARY_PASSWORD` y se hashea con `bcryptjs`. **Esta contrase√±a (`password123`) es la que usar√≠as para hacer login con los usuarios sembrados, a trav√©s de NextAuth (cuando lo configuremos).**
3.  **Seed Categor√≠as:**
    *   Itera sobre `mockCategorias`.
    *   Usa `prisma.categoria.upsert` para crear la categor√≠a si no existe (basado en el `nombre` que extraemos del `id` del mock, ej. 'vinos'), o no hacer nada si ya existe.
    *   Guarda las categor√≠as creadas en `categoriasMap` para f√°cil acceso.
4.  **Seed Productores y Productos:**
    *   Itera sobre `mockProductoresData`.
    *   **Crea un `User`:**
        *   Genera un email ficticio (`productor1@example.com`, etc.).
        *   Busca si el usuario ya existe por email.
        *   Si no existe, lo crea con el email, el nombre del productor, y el rol `PRODUCTOR`.
        *   **Nota sobre la contrase√±a:** El script hashea una contrase√±a, pero el modelo `User` est√°ndar de NextAuth no incluye un campo `password`. La verificaci√≥n de contrase√±a con el proveedor "Credentials" de NextAuth se hace comparando el hash de la contrase√±a que se almacenar√≠a (si se personaliza el modelo `User` para incluirla o se usa una tabla separada) con el hash de la contrase√±a ingresada. Para este seed, el `HASHED_PASSWORD` es conceptual; el login se configurar√° despu√©s.
    *   **Crea/Actualiza un `Productor`:**
        *   Usa `prisma.productor.upsert` para crear o actualizar el productor, vincul√°ndolo al `User` y `Categoria` correspondientes.
        *   Se asume que `productor.userId` es √∫nico.
        *   Los productores se marcan como `aprobado: true`.
    *   **Crea/Actualiza `Producto`s:**
        *   Itera sobre los productos del productor.
        *   Usa `prisma.producto.upsert` para crear o actualizar cada producto. Para que `upsert` funcione de manera predecible y evite duplicados en re-ejecuciones, he usado un `id` determinista compuesto por `productor.id` y `productoData.id` (del mock). Esto asume que `productoData.id` es √∫nico dentro de los productos de un productor en tus datos mock.
5.  **Idempotencia:** El uso de `upsert` ayuda a que el script sea m√°s seguro de ejecutar m√∫ltiples veces, aunque la parte de productos es un poco m√°s compleja sin un unique natural en los datos mock aparte del ID. La generaci√≥n de IDs deterministas para el seed ayuda.
6.  **Ruta de Importaci√≥n:** `import { productoresData, categorias } from '../src/data/productores';` asume que tu archivo `productores.ts` est√° en `src/data/`. Ajusta esta ruta si es diferente.
7.  **Consola:** Hay `console.log` para ver el progreso.

**Pr√≥ximos pasos para ti (localmente):**

1.  **Aseg√∫rate de haber instalado localmente (si los pasos anteriores fallaron para m√≠):**
    *   `npm install prisma --save-dev`
    *   `npm install @prisma/client`
    *   `npm install ts-node --save-dev`
    *   `npm install bcryptjs`
    *   `npm install @types/bcryptjs --save-dev`
2.  **Copia el c√≥digo de arriba y gu√°rdalo en `prisma/seed.ts` en tu proyecto local.**
3.  **Actualiza tu `package.json` localmente.** Abre `package.json` y a√±ade la secci√≥n `prisma` si no existe, o modif√≠cala:
    ```json
    {
      // ... otras cosas de tu package.json ...
      "prisma": {
        "seed": "ts-node prisma/seed.ts"
      }
    }
    ```
4.  **Ejecuta el seed en tu terminal local:**
    ```bash
    npx prisma db seed
    ```
5.  Verifica la salida en la consola y revisa tu base de datos Neon (usando alguna herramienta de BD o el explorador de Neon) para ver si los datos se crearon.
6.  Si todo funciona, **haz commit y push** de `prisma/seed.ts` y los cambios en `package.json` y `package-lock.json` a tu repositorio.

Av√≠same cuando hayas podido ejecutar el seed localmente o si encuentras alg√∫n problema. Este es un paso grande.
